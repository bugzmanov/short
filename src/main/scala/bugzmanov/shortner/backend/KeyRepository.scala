package bugzmanov.shortner.backend

import scalikejdbc._, SQLInterpolation._
import java.math.BigInteger
import org.apache.commons.codec.digest.DigestUtils
import bugzmanov.shortner.util.UrlEncoder
import shapeless.singleton

trait KeyRepository {
  def store(url: String): String
  def get(key:String): Option[String]
}

class SqlDBKeyRepository(driver: String = "org.h2.Driver", jdbcURL: String = "jdbc:h2:mem:shortner") extends KeyRepository {

  Class.forName(driver)
  ConnectionPool.singleton(jdbcURL, "", "")

  implicit val session = DB.autoCommitSession


  // tradeoff: race condition can occur in case of inserting same url simultaneously (will get different keys) and store two records
  // 8 byte restriction come from h2 having largest numeric field as 8 byte
  // having single point of synchronization for each id is a bad thing, in real world would use sequences and HiLo algorithm to synchronize less
  def store(url: String): String = {
    val hash = new BigInteger(DigestUtils.md5(url).take(8)).longValue()

    val id = sql"""select * from urls where hash = $hash and url = $url""".map (_.long("id")).first().apply()


    UrlEncoder.encode (id.getOrElse {
      DB localTx { implicit session => // todo: post an issue to scalikejdbc guys: they are getting autogenerated key after commit
        sql"""insert into urls (url, hash) values ($url, $hash)""".updateAndReturnGeneratedKey().apply()
      }
    })
  }

  def get(key: String): Option[String] = {
    val id = UrlEncoder.decode(key)
    sql"""select url from urls where id = $id""".map (rs => rs.string("url")).headOption().apply()
  }

  def createSchema() {
    sql"""
      create table urls (
        id identity not null primary key,
        url varchar(2000) not null,
        hash BIGINT not null
    )""".execute().apply()

    sql"""create index hash_index on urls (hash)""".execute().apply()
  }

  def cleanUp() {
    sql"""drop index hash_index """.execute().apply()
    sql"""drop table urls """.execute().apply()
  }
}